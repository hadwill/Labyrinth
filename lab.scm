;;; OOP Labyrinths

(define (make-node name)
  (let ((status 'non-visited)
	(neighbors '())
	(origin '()))
    (define (non-visited)
      (define (helper hood)
	(if (null? hood)
	    '()
	    (let ((first-neighbor (car hood)))
	      (let ((first-neighbor-status (get-status first-neighbor)))
		(cond ((eq? 'visited first-neighbor-status)
		       (helper (cdr hood)))
		      ((eq? 'non-visited first-neighbor-status)
		       (cons first-neighbor (helper (cdr hood))))
		      (else
		       (error "Incorrect status -- "
			      (list first-neighbor
				    first-neighbor-status))))))))
      (helper neighbors))
    (define (already-neighbor? node)
      (define (helper x list)
	(cond ((null? list)
	       false)
	      ((eq? (car list) x)
	       true)
	      (else
	       (helper x (cdr list)))))
      (helper node neighbors))
    (define (add-neighbor! node)
	(cond ((null? neighbors)
	       (set! neighbors (list node)))
	      ((already-neighbor? node)
	       'ok)
	      (else
	       (set-cdr! neighbors (list node)))))
    (define (get-origin)
      (if (null? origin)
	  '()
	  (car origin)))
    (define (self message)
      (cond
       ((eq? message 'get-name)
	name)
       ((eq? message 'status)
	status)
       ((eq? message 'status-visited)
	(set! status 'visited))
       ((eq? message 'neighbors)
	neighbors)
       ((eq? message 'add-neighbor!)
	(lambda (x) (add-neighbor! x)))
       ((eq? message 'origin)
	(get-origin))
       ((eq? message 'set-origin!)
	(lambda (o) (set! origin (list o))))
       ((eq? message 'get-non-visited)
	(non-visited))
       ((eq? message 'next-non-visited)
	(car (non-visited)))))
    self))

(define (get-name node) (node 'get-name))
(define (get-status node) (node 'status))
(define (status-visited! node) (node 'status-visited))
(define (get-neighbors node) (node 'neighbors))
(define (add-neighbor! node1 node2)
  ((node1 'add-neighbor!) node2))
(define (get-origin node) (node 'origin))
(define (set-origin! node1 node2)
  ((node1 'set-origin!) node2))
(define (get-non-visited node) ;untested
  (node 'get-non-visited))
(define (next-non-visited node) ; untested
  (node 'next-non-visited))

(define (connect node1 node2)
  (begin
    (add-neighbor! node1 node2)
    (add-neighbor! node2 node1)))

(define (find-exit node past-nodes)
  (define (move message node)
    (cond ((eq? 'back message)
	   (status-visited! node)
	   (find-exit (get-origin node)
		      (append past-nodes (list (get-name node)))))
	  ((eq? 'forward message)
	   (status-visited! node)
	   (set-origin! (next-non-visited node) node)
	   (find-exit (next-non-visited node)
		      (append past-nodes (list (get-name node)))))))
  (cond ((eq? 'EXIT (get-name node))
	 (append past-nodes '(*EXIT*)))
	((null? (get-non-visited node))
	 (move 'back node))
	(else
	 (move 'forward node))))

;; TESTS

(define a (make-node 'a))
(define b (make-node 'b))
(define c (make-node 'c))
(define exit (make-node 'exit))
(newline)
(display "A, B, C and EXIT nodes created")
(newline)
(display "A's neighbors : ")
(display (get-neighbors a))
(newline)
(connect a b)
(connect  a c)
;(connect b c)
(connect c exit)
(display "nodes connected")
(newline)
(display "A's neighbors : ")
(display (get-neighbors a))
(newline)
(display "A's non-visited-neighbors : ")
(display (map get-name (get-non-visited a)))
(newline)
(display "A's next non-visited-neighbor : ")
(display (get-name (next-non-visited a)))
(newline)
(display (find-exit a '()))
